(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{147:function(t,e,a){t.exports=a.p+"assets/img/diff.fa0a68eb.png"},148:function(t,e,a){t.exports=a.p+"assets/img/tree.4ee8867c.png"},149:function(t,e,a){t.exports=a.p+"assets/img/treediff.6300b133.png"},150:function(t,e,a){t.exports=a.p+"assets/img/list.7872fbeb.png"},157:function(t,e,a){"use strict";a.r(e);var r=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"react-虚拟dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-虚拟dom","aria-hidden":"true"}},[t._v("#")]),t._v(" React 虚拟dom")]),t._v(" "),r("h4",{attrs:{id:"虚拟dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom","aria-hidden":"true"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),r("ul",[r("li",[t._v("虚拟DOM的简单实现（diff算法）")]),t._v(" "),r("li",[t._v("虚拟DOM的内部工作原理")]),t._v(" "),r("li",[t._v("React中的虚拟DOM与Vue中的虚拟DOM比较")])]),t._v(" "),r("h4",{attrs:{id:"那么虚拟dom和dom之间的关系是什么呢？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#那么虚拟dom和dom之间的关系是什么呢？","aria-hidden":"true"}},[t._v("#")]),t._v(" 那么虚拟DOM和DOM之间的关系是什么呢？")]),t._v(" "),r("ul",[r("li",[t._v("Virtual DOM并没有完全实现DOM，即虚拟DOM和真正地DOM是不一样的")]),t._v(" "),r("li",[t._v("Virtual DOM最主要的还是保留了Element之间的层次关系和一些基本属性。")]),t._v(" "),r("li",[t._v("因为真实DOM实在是太复杂，一个空的Element都复杂得能让你崩溃，并且几乎所有内容我根本不关心好吗。所以Virtual DOM里每一个Element实际上只有几个属性，即最重要的，最为有用的，并且没有那么多乱七八糟的引用，比如一些注册的属性和函数啊，这些都是默认的，创建虚拟DOM进行diff的过程中大家都一致，是不需要进行比对的。")]),t._v(" "),r("li",[t._v("哪怕是直接把Virtual DOM删了，根据新传进来的数据重新创建一个新的Virtual DOM出来都非常非常非常快。（每一个component的render函数就是在做这个事情，给新的virtual dom提供input）。")])]),t._v(" "),r("h4",{attrs:{id:"虚拟dom的简单实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的简单实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 虚拟dom的简单实现")]),t._v(" "),r("ul",[r("li",[t._v("用JS对象模拟DOM树")]),t._v(" "),r("li",[t._v("比较两棵虚拟DOM树的差异")]),t._v(" "),r("li",[t._v("把差异应用到真正的DOM树上")])]),t._v(" "),r("h4",{attrs:{id:"_1、用js对象模拟dom树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、用js对象模拟dom树","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、用JS对象模拟DOM树")]),t._v(" "),r("ul",[r("li",[t._v("首先我们要明白"),r("strong",[t._v("真实的DOM元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。")])]),t._v(" "),r("li",[t._v("而相对于DOM对象，"),r("strong",[t._v("原生的JavaScript对象")]),t._v("处理起来更快，而且更简单，"),r("strong",[t._v("DOM树上的结构信息我们都可以使用JavaScript对象很容易的表示出来")]),t._v("。")])]),t._v(" "),r("h3",{attrs:{id:"diff简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#diff简介","aria-hidden":"true"}},[t._v("#")]),t._v(" diff简介")]),t._v(" "),r("blockquote",[r("p",[r("img",{attrs:{src:a(147),alt:"Alt text"}})])]),t._v(" "),r("p",[t._v("DIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。")]),t._v(" "),r("blockquote",[r("p",[r("img",{attrs:{src:a(148),alt:"Alt text"}})])]),t._v(" "),r("p",[r("strong",[t._v("Tree DIFF")]),t._v("是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，第一层是R组件，一模一样，不会发生变化；第二层进入Component DIFF，同一类型组件继续比较下去，发现A组件没有，所以直接删掉A、B、C组件；继续第三层，重新创建A、B、C组件。")]),t._v(" "),r("blockquote",[r("p",[r("img",{attrs:{src:a(149),alt:"Alt text"}})])]),t._v(" "),r("p",[t._v("从图上我么可以知道，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建")]),t._v(" "),r("blockquote",[r("p",[r("img",{attrs:{src:a(150),alt:"Alt text"}})])]),t._v(" "),r("p",[t._v("Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可")])])}],i=a(0),s=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);e.default=s.exports}}]);